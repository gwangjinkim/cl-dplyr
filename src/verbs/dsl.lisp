(in-package #:cl-dplyr)

;; 1. Vectorized Boolean Operators (missing from cl-vctrs-lite)
(defun v-and (&rest args)
  (if (null args)
      #(t)
      (reduce (lambda (a b) (cl-vctrs-lite:col-map (lambda (x y) (and x y)) a b)) args)))

(defun v-or (&rest args)
  (if (null args)
      #(nil)
      (reduce (lambda (a b) (cl-vctrs-lite:col-map (lambda (x y) (or x y)) a b)) args)))

(defun v-not (a)
  (cl-vctrs-lite:col-map #'not a))

;; 2. DSL Operator Mapping
(defparameter *dsl-operators*
  '((==  . cl-vctrs-lite:v=)
    (%=  . cl-vctrs-lite:v=)
    (/=  . cl-vctrs-lite:v=) 
    (!=  . cl-vctrs-lite:v=) 
    (>   . cl-vctrs-lite:v>)
    (<   . cl-vctrs-lite:v<)
    (>=  . cl-vctrs-lite:v>=)
    (<=  . cl-vctrs-lite:v<=)
    (+   . cl-vctrs-lite:v+)
    (-   . cl-vctrs-lite:v-)
    (*   . cl-vctrs-lite:v*)
    (/   . cl-vctrs-lite:v/)
    (&   . v-and)
    (|\||  . v-or)
    (!   . v-not)))

;; 3. DSL Expansion Core
(defun unquote-col (c)
  "Convert symbol to keyword if not already keyword."
  (cond
    ((keywordp c) c)
    ((symbolp c) (values (intern (string-upcase c) :keyword)))
    (t c)))

(defun parse-dsl (expr df-sym)
  (cond
    ((null expr) nil)
    ((or (eq expr :n) (eq expr 'n)) `(cl-tibble:tbl-nrows ,df-sym))
    ((and (consp expr) (eq (first expr) 'n)) `(cl-tibble:tbl-nrows ,df-sym))
    ((keywordp expr) `(cl-tibble:tbl-col ,df-sym ,expr))
    ((symbolp expr)
     `(cl-tibble:tbl-col ,df-sym ,(unquote-col expr)))
    ((consp expr)
     (let ((head (car expr)))
       (case head
         (:col `(cl-tibble:tbl-col ,df-sym ,(unquote-col (second expr))))
         (:row (error "Row access via #r is not supported by cl-tibble."))
          (t
           (let ((name (symbol-name head)))
             (cond
               ((or (string-equal name "SUM") (string-equal name ".SUM"))
                `(aggregate-sum ,(parse-dsl (second expr) df-sym)))
               ((or (string-equal name "MEAN") (string-equal name ".MEAN"))
                `(aggregate-mean ,(parse-dsl (second expr) df-sym)))
               ((or (string-equal name "MIN") (string-equal name ".MIN"))
                `(aggregate-min ,(parse-dsl (second expr) df-sym)))
               ((or (string-equal name "MAX") (string-equal name ".MAX"))
                `(aggregate-max ,(parse-dsl (second expr) df-sym)))
               ((or (string-equal name "N") (string-equal name ".N") 
                    (string-equal name "COUNT") (string-equal name ".COUNT"))
                `(cl-tibble:tbl-nrows ,df-sym))
               ((or (string-equal name "FIRST") (string-equal name ".FIRST"))
                `(v-first ,(parse-dsl (second expr) df-sym)))
               ((or (string-equal name "LAST") (string-equal name ".LAST"))
                `(v-last ,(parse-dsl (second expr) df-sym)))
               ((or (string-equal name "NTH") (string-equal name ".NTH"))
                `(v-nth ,(parse-dsl (second expr) df-sym) ,(third expr)))
               ((or (string-equal name "ROW_NUMBER") 
                    (string-equal name "ROW-NUMBER")
                    (string-equal name ".ROW-NUMBER")
                    (string-equal name ".ROW_NUMBER"))
                `(alexandria:iota (cl-tibble:tbl-nrows ,df-sym) :start 1))
               ((or (string-equal name "IF_ELSE") (string-equal name ".IF_ELSE") (string-equal name ".if-else"))
                `(if-else ,(parse-dsl (second expr) df-sym) 
                          ,(parse-dsl (third expr) df-sym)
                          ,(parse-dsl (fourth expr) df-sym)))
               ((or (string-equal name "CASE_WHEN") (string-equal name ".CASE_WHEN") (string-equal name ".case-when"))
                `(case-when ,@(loop for (cond val) in (cdr expr)
                                    collect `(,(parse-dsl cond df-sym) ,(parse-dsl val df-sym)))))
               ((or (string-equal name "DESC") (string-equal name ".DESC"))
                `(.desc ,(parse-dsl (second expr) df-sym)))
               ((or (string-equal name "ASC") (string-equal name ".ASC"))
                `(.asc ,(parse-dsl (second expr) df-sym)))
               ((or (string-equal name "N_DISTINCT") (string-equal name ".N_DISTINCT") (string-equal name "N-DISTINCT") (string-equal name ".N-DISTINCT"))
                `(.n-distinct ,(parse-dsl (second expr) df-sym)))
               (t 
                (let ((op (assoc head *dsl-operators*)))
                  (if op
                      `(,(cdr op) ,@(mapcar (lambda (e) (parse-dsl e df-sym)) (rest expr)))
                      (cons head (mapcar (lambda (e) (parse-dsl e df-sym)) (rest expr))))))))))))
    (t expr)))

;; 4. DSL Verb transformation (for use inside ->)
(defun expand-dsl-form (form)
  "Expand DSL-specific verbs in a form."
  (if (consp form)
      (let ((name (symbol-name (first form))))
        (cond
          ((or (string-equal name "SELECT") (string-equal name ".SELECT"))
           (cons '.select (mapcar #'unquote-col (rest form))))
          ((or (string-equal name "RENAME") (string-equal name ".RENAME"))
           (cons '.rename (mapcar #'unquote-col (rest form))))
          ((or (string-equal name "ARRANGE") (string-equal name ".ARRANGE"))
           (cons '.arrange (rest form)))
          ((or (string-equal name "FILTER") (string-equal name ".FILTER"))
           (let ((df-sym (gensym "DF")))
             `(.filter (lambda (,df-sym) ,(parse-dsl (second form) df-sym)))))
          ((or (string-equal name "MUTATE") (string-equal name ".MUTATE"))
           (let ((df-sym (gensym "DF")))
             `(.mutate ,@(loop for (col expr) on (rest form) by #'cddr
                               append `(,(unquote-col col) (lambda (,df-sym) ,(parse-dsl expr df-sym)))))))
          ((or (string-equal name "SUMMARISE") (string-equal name ".SUMMARISE")
               (string-equal name "SUMMARIZE") (string-equal name ".SUMMARIZE"))
           (let ((df-sym (gensym "DF")))
             `(.summarise ,@(loop for (col expr) on (rest form) by #'cddr
                                  append `(,(unquote-col col) (lambda (,df-sym) ,(parse-dsl expr df-sym)))))))
          ((or (string-equal name "SLICE") (string-equal name ".SLICE"))
           (cons '.slice (rest form)))
          ((or (string-equal name "DISTINCT") (string-equal name ".DISTINCT"))
           (cons '.distinct (mapcar #'unquote-col (rest form))))
          ((or (string-equal name "GROUP_BY") (string-equal name ".GROUP_BY")
               (string-equal name "GROUP-BY") (string-equal name ".GROUP-BY"))
           (cons '.group-by (mapcar #'unquote-col (rest form))))
          ((or (string-equal name "UNGROUP") (string-equal name ".UNGROUP"))
           (cons '.ungroup (rest form)))
          ((or (string-equal name "PULL") (string-equal name ".PULL"))
           (cons '.pull (rest form)))
          ((or (string-equal name "INNER_JOIN") (string-equal name "INNER-JOIN") (string-equal name ".INNER-JOIN"))
           (cons '.inner-join (rest form)))
          ((or (string-equal name "LEFT_JOIN") (string-equal name "LEFT-JOIN") (string-equal name ".LEFT-JOIN"))
           (cons '.left-join (rest form)))
          ((or (string-equal name "RIGHT_JOIN") (string-equal name "RIGHT-JOIN") (string-equal name ".RIGHT-JOIN"))
           (cons '.right-join (rest form)))
          ((or (string-equal name "FULL_JOIN") (string-equal name "FULL-JOIN") (string-equal name ".FULL-JOIN"))
           (cons '.full-join (rest form)))
          ((or (string-equal name "SEMI_JOIN") (string-equal name "SEMI-JOIN") (string-equal name ".SEMI-JOIN"))
           (cons '.semi-join (rest form)))
          ((or (string-equal name "ANTI_JOIN") (string-equal name "ANTI-JOIN") (string-equal name ".ANTI-JOIN"))
           (cons '.anti-join (rest form)))
          (t form)))
      form))

;; 5. Threading Macros
(defun placeholder-p (x)
  (and (symbolp x) (string= (symbol-name x) "_")))

(defun contains-placeholder-p (tree)
  (cond
    ((placeholder-p tree) t)
    ((consp tree) (or (contains-placeholder-p (car tree))
                      (contains-placeholder-p (cdr tree))))
    (t nil)))

(defun replace-placeholder (tree value)
  (cond
    ((placeholder-p tree) value)
    ((consp tree) (cons (replace-placeholder (car tree) value)
                        (replace-placeholder (cdr tree) value)))
    (t tree)))

(defmacro -> (x &rest forms)
  (reduce (lambda (val form)
            (let ((expanded (expand-dsl-form form)))
              (if (contains-placeholder-p expanded)
                  (replace-placeholder expanded val)
                  (if (listp expanded)
                      `(,(first expanded) ,val ,@(rest expanded))
                      `(,expanded ,val)))))
          forms
          :initial-value x))

(defmacro ->> (x &rest forms)
  (reduce (lambda (val form)
            (let ((expanded (expand-dsl-form form)))
              (if (contains-placeholder-p expanded)
                  (replace-placeholder expanded val)
                  (if (listp expanded)
                      `(,@expanded ,val)
                      `(,expanded ,val)))))
          forms
          :initial-value x))
